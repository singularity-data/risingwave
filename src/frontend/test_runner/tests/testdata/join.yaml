# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v3 int, v4 int);
    create table t3 (v5 int, v6 int);
    select * from t1, t2, t3 where t1.v1 = t2.v3 and t1.v1 = t3.v5;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4, t3.v5, t3.v6] }
      LogicalFilter { predicate: (t1.v1 = t2.v3) AND (t1.v1 = t3.v5) }
        LogicalJoin { type: Inner, on: true }
          LogicalJoin { type: Inner, on: true }
            LogicalScan { table: t1, columns: [_row_id, v1, v2] }
            LogicalScan { table: t2, columns: [_row_id, v3, v4] }
          LogicalScan { table: t3, columns: [_row_id, v5, v6] }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, v3, v4, v5, v6, t1._row_id(hidden), t2._row_id(hidden), t3._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, t3._row_id] }
      StreamExchange { dist: HashShard(t1._row_id, t2._row_id, t3._row_id) }
        StreamHashJoin { type: Inner, predicate: t1.v1 = t3.v5 }
          StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v3 }
            StreamExchange { dist: HashShard(t1.v1) }
              StreamTableScan { table: t1, columns: [v1, v2, _row_id] }
            StreamExchange { dist: HashShard(t2.v3) }
              StreamTableScan { table: t2, columns: [v3, v4, _row_id] }
          StreamExchange { dist: HashShard(t3.v5) }
            StreamTableScan { table: t3, columns: [v5, v6, _row_id] }
- sql: |
    /* self join */
    create table t (v1 int, v2 int);
    select t1.v1 as t1v1, t2.v1 as t2v1 from t t1 join t t2 on t1.v1 = t2.v1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v1] }
      LogicalJoin { type: Inner, on: (t.v1 = t.v1) }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
  stream_plan: |
    StreamMaterialize { columns: [t1v1, t2v1, t._row_id(hidden), t._row_id#1(hidden)], pk_columns: [t._row_id, t._row_id#1] }
      StreamExchange { dist: HashShard(t._row_id, t._row_id) }
        StreamHashJoin { type: Inner, predicate: t.v1 = t.v1 }
          StreamExchange { dist: HashShard(t.v1) }
            StreamTableScan { table: t, columns: [v1, _row_id] }
          StreamExchange { dist: HashShard(t.v1) }
            StreamTableScan { table: t, columns: [v1, _row_id] }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create table t3 (v1 int, v2 int);
    select t1.v1 as t1_v1, t1.v2 as t1_v2, t2.v1 as t2_v1, t2.v2 as t2_v2, t3.v1 as t3_v1, t3.v2 as t3_v2 from t1 join t2 on (t1.v1 = t2.v1) join t3 on (t2.v2 = t3.v2);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: t2.v2 = t3.v2 }
        BatchExchange { order: [], dist: HashShard(t2.v2) }
          BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1 }
            BatchExchange { order: [], dist: HashShard(t1.v1) }
              BatchScan { table: t1, columns: [v1, v2] }
            BatchExchange { order: [], dist: HashShard(t2.v1) }
              BatchScan { table: t2, columns: [v1, v2] }
        BatchExchange { order: [], dist: HashShard(t3.v2) }
          BatchScan { table: t3, columns: [v1, v2] }
  batch_local_plan: |
    BatchHashJoin { type: Inner, predicate: t2.v2 = t3.v2 }
      BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1 }
        BatchExchange { order: [], dist: Single }
          BatchScan { table: t1, columns: [v1, v2] }
        BatchExchange { order: [], dist: Single }
          BatchScan { table: t2, columns: [v1, v2] }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t3, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { columns: [t1_v1, t1_v2, t2_v1, t2_v2, t3_v1, t3_v2, t1._row_id(hidden), t2._row_id(hidden), t3._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, t3._row_id] }
      StreamExchange { dist: HashShard(t1._row_id, t2._row_id, t3._row_id) }
        StreamHashJoin { type: Inner, predicate: t2.v2 = t3.v2 }
          StreamExchange { dist: HashShard(t2.v2) }
            StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v1 }
              StreamExchange { dist: HashShard(t1.v1) }
                StreamTableScan { table: t1, columns: [v1, v2, _row_id] }
              StreamExchange { dist: HashShard(t2.v1) }
                StreamTableScan { table: t2, columns: [v1, v2, _row_id] }
          StreamExchange { dist: HashShard(t3.v2) }
            StreamTableScan { table: t3, columns: [v1, v2, _row_id] }
- sql: |
    create table t1 (v1 int not null, v2 int not null);
    create table t2 (v1 int not null, v2 int not null);
    select t1.v2 as t1_v2, t2.v2 as t2_v2 from t1 join t2 on t1.v1 = t2.v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1 }
        BatchExchange { order: [], dist: HashShard(t1.v1) }
          BatchScan { table: t1, columns: [v1, v2] }
        BatchExchange { order: [], dist: HashShard(t2.v1) }
          BatchScan { table: t2, columns: [v1, v2] }
  batch_local_plan: |
    BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1 }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t1, columns: [v1, v2] }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t2, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { columns: [t1_v2, t2_v2, t1._row_id(hidden), t2._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id] }
      StreamExchange { dist: HashShard(t1._row_id, t2._row_id) }
        StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v1 }
          StreamExchange { dist: HashShard(t1.v1) }
            StreamTableScan { table: t1, columns: [v1, v2, _row_id] }
          StreamExchange { dist: HashShard(t2.v1) }
            StreamTableScan { table: t2, columns: [v1, v2, _row_id] }
- sql: |
    create table t1 (v1 int not null, v2 int not null);
    create table t2 (v1 int not null, v2 int not null);
    select t1.v2 as t1_v2, t2.v2 as t2_v2 from t1 join t2 on t1.v1 > t2.v1 and t1.v2 < 10;
  batch_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: (t1.v1 > t2.v1) }
      BatchExchange { order: [], dist: Single }
        BatchFilter { predicate: (t1.v2 < 10:Int32) }
          BatchScan { table: t1, columns: [v1, v2] }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t2, columns: [v1, v2] }
  batch_local_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: (t1.v1 > t2.v1) }
      BatchExchange { order: [], dist: Single }
        BatchFilter { predicate: (t1.v2 < 10:Int32) }
          BatchScan { table: t1, columns: [v1, v2] }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t2, columns: [v1, v2] }
- sql: |
    create table t1 (v1 int, v2 float);
    create table t2 (v3 int, v4 numeric, v5 bigint);
    select * from t1, t2 where t1.v1 = t2.v3;
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, v3, v4, v5, t1._row_id(hidden), t2._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id] }
      StreamExchange { dist: HashShard(t1._row_id, t2._row_id) }
        StreamDeltaHashJoin { type: Inner, predicate: t1.v1 = t2.v3 }
          StreamExchange { dist: HashShard(t1.v1) }
            StreamTableScan { table: t1, columns: [v1, v2, _row_id] }
          StreamExchange { dist: HashShard(t2.v3) }
            StreamTableScan { table: t2, columns: [v3, v4, v5, _row_id] }
  with_config_map:
    RW_FORCE_DELTA_JOIN: "true"
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v3 int);
    select * from t1 join t2 using(v1);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1 }
        BatchExchange { order: [], dist: HashShard(t1.v1) }
          BatchScan { table: t1, columns: [v1, v2] }
        BatchExchange { order: [], dist: HashShard(t2.v1) }
          BatchScan { table: t2, columns: [v1, v3] }
- sql: |
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table ca (c int, a int);
    select * from ab join bc using(b) join ca using(c);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: bc.c = ca.c }
        BatchExchange { order: [], dist: HashShard(bc.c) }
          BatchHashJoin { type: Inner, predicate: ab.b = bc.b }
            BatchExchange { order: [], dist: HashShard(ab.b) }
              BatchScan { table: ab, columns: [a, b] }
            BatchExchange { order: [], dist: HashShard(bc.b) }
              BatchScan { table: bc, columns: [b, c] }
        BatchExchange { order: [], dist: HashShard(ca.c) }
          BatchScan { table: ca, columns: [c, a] }
- sql: |
    /* Only push to left */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1 left join t2 where t1.v2 > 100;
  optimized_logical_plan: |
    LogicalJoin { type: LeftOuter, on: true }
      LogicalScan { table: t1, output_columns: [v1, v2], required_columns: [v1, v2], predicate: (t1.v2 > 100:Int32) }
      LogicalScan { table: t2, columns: [v1, v2] }
- sql: |
    /* Only push to right */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1 right join t2 where t2.v2 > 100;
  optimized_logical_plan: |
    LogicalJoin { type: RightOuter, on: true }
      LogicalScan { table: t1, columns: [v1, v2] }
      LogicalScan { table: t2, output_columns: [v1, v2], required_columns: [v1, v2], predicate: (t2.v2 > 100:Int32) }
- sql: |
    /* Push to left, right and on */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1, t2 where t1.v1 > 100 and t2.v1 < 1000 and t1.v2 = t2.v2;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v2 = t2.v2) }
      LogicalScan { table: t1, output_columns: [v1, v2], required_columns: [v1, v2], predicate: (t1.v1 > 100:Int32) }
      LogicalScan { table: t2, output_columns: [v1, v2], required_columns: [v1, v2], predicate: (t2.v1 < 1000:Int32) }
- sql: |
    /* Left & right has same distribution. There should be no exchange below hash join */
    create table t(x int);
    create index i on t(x);
    select * from i join i as ii on i.x=ii.x;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: i.x = i.x }
        BatchScan { table: i, columns: [x] }
        BatchScan { table: i, columns: [x] }
- sql: |
    /* Use lookup join */
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create materialized view t3 as select v1, count(v2) as v2 from t2 group by v1;
    select * from t1 join t3 where t1.v2 = t3.v1;
  batch_local_plan: |
    BatchLookupJoin { type: Inner, predicate: t1.v2 = t3.v1 }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: t1, columns: [v1, v2] }
  with_config_map:
    QUERY_MODE: local
    RW_BATCH_ENABLE_LOOKUP_JOIN: "true"
- sql: |
    /* Ensure correct binding of join with USING clause */
    create table t1(v1 varchar);
    create table t2(v1 varchar);
    create table t3(v2 varchar);
    select * from t3, t1 join t2 using (v1);
  logical_plan: |
    LogicalProject { exprs: [t3.v2, t1.v1, t2.v1] }
      LogicalJoin { type: Inner, on: true }
        LogicalScan { table: t3, columns: [_row_id, v2] }
        LogicalJoin { type: Inner, on: (t1.v1 = t2.v1) }
          LogicalScan { table: t1, columns: [_row_id, v1] }
          LogicalScan { table: t2, columns: [_row_id, v1] }
- sql: |
    /* Ensure correct binding of join with ON clause */
    create table t1(v1 varchar);
    create table t2(v2 varchar);
    create table t3(v3 varchar);
    select * from t3, t1 join t2 on v1 = v2;
  logical_plan: |
    LogicalProject { exprs: [t3.v3, t1.v1, t2.v2] }
      LogicalJoin { type: Inner, on: true }
        LogicalScan { table: t3, columns: [_row_id, v3] }
        LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
          LogicalScan { table: t1, columns: [_row_id, v1] }
          LogicalScan { table: t2, columns: [_row_id, v2] }
- sql: |
    /* Ensure correct binding with USING clause with left outer join */
    create table t1(v1 varchar);
    create table t2(v1 varchar);
    create table t3(v2 varchar);
    select * from t3, t1 left join t2 using (v1);
  logical_plan: |
    LogicalProject { exprs: [t3.v2, t1.v1, t2.v1] }
      LogicalJoin { type: Inner, on: true }
        LogicalScan { table: t3, columns: [_row_id, v2] }
        LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v1) }
          LogicalScan { table: t1, columns: [_row_id, v1] }
          LogicalScan { table: t2, columns: [_row_id, v1] }
- sql: |
    /* Ensure correct binding with ON clause with left outer join */
    create table t1(v1 varchar);
    create table t2(v2 varchar);
    create table t3(v3 varchar);
    select * from t3, t1 left join t2 on v1 = v2;
  logical_plan: |
    LogicalProject { exprs: [t3.v3, t1.v1, t2.v2] }
      LogicalJoin { type: Inner, on: true }
        LogicalScan { table: t3, columns: [_row_id, v3] }
        LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v2) }
          LogicalScan { table: t1, columns: [_row_id, v1] }
          LogicalScan { table: t2, columns: [_row_id, v2] }
- sql: |
    /* Ensure that ON clause cannot reference correlated columns */
    create table a(a1 int);
    create table b(b1 int);
    create table c(c1 int);
    select * from a, b join c on a1 + b1 = c1;
  binder_error: 'Item not found: Invalid column: a1'
- sql: |
    create table a(a1 int);
    create table b(b1 int);
    select * from a join lateral (select * from b where a1 = b1);
  binder_error: 'Feature is not yet implemented: lateral subqueries are not yet supported, Tracking issue: https://github.com/singularity-data/risingwave/issues/3815'
- sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1, t2 where t1.x + t1.y = t2.x + t2.y;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ((t1.x + t1.y) = (t2.x + t2.y)) }
      LogicalProject { exprs: [t1.x, t1.y, (t1.x + t1.y)] }
        LogicalScan { table: t1, columns: [x, y] }
      LogicalProject { exprs: [t2.x, t2.y, (t2.x + t2.y)] }
        LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x int, y int);
    create table t2(x float, y int);
    select * from t1, t2 where t1.x + t1.y = t2.x;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ((t1.x + t1.y)::Float64 = t2.x) }
      LogicalProject { exprs: [t1.x, t1.y, (t1.x + t1.y)::Float64] }
        LogicalScan { table: t1, columns: [x, y] }
      LogicalProject { exprs: [t2.x, t2.y, t2.x] }
        LogicalScan { table: t2, columns: [x, y] }
- sql: |
    create table t1(x decimal, y int);
    create table t2(x float, y int);
    select * from t1, t2 where t1.x + t1.y = t2.x + t2.y;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ((t1.x + t1.y)::Float64 = (t2.x + t2.y)) }
      LogicalProject { exprs: [t1.x, t1.y, (t1.x + t1.y)::Float64] }
        LogicalScan { table: t1, columns: [x, y] }
      LogicalProject { exprs: [t2.x, t2.y, (t2.x + t2.y)] }
        LogicalScan { table: t2, columns: [x, y] }
